<table style="width:100%">
  <tr>
    <td align="left"><a href="../1.3/README.md">⬅️ Previous</a></td>
    <td align="right"><a href="../1.5/README.md">Next ➡️</a></td>
  </tr>
</table>

# 4. Running a Real Service (LAMP Stack)

This section creates a basic **LAMP stack** (Linux, Apache, MariaDB, PHP) based on Dockerized components.
Following the *“one service per container”* philosophy, two separate containers will be run:
one executing the web server (`apache` with the `php` interpreter) and one handling the database server (`mariadb`).

Modularity is a very important concept in Docker, as it keeps applications separated, improves maintainability, and enables the reuse of containers across different setups.

## 4.1. Running the Web Server

Create a new `apache` container:

```bash
sudo docker run -d --name dockerlab-apache --rm -p 8080:80 httpd:2.4-alpine
```

**Explanation:**

* `-d`: runs the container in the background.

> [!NOTE] 
> Without this flag, Apache starts using the console as its standard input/output, preventing the execution of other commands in the same shell.

* `-p`: exposes the container’s internal port `80` (HTTP) on port `8080` of the host.
  This makes the application appear as if it were running directly on the host.

To verify that the web server is working, open [http://localhost:8080](http://localhost:8080) in your browser,
or run:

```bash
wget -qO- http://localhost:8080
```

You should see the message **“It works!”**.

## 4.2. Populating the Apache Container with Embedded HTML Pages

You now have a running web server container.
However, it is useless unless you can specify the content to be served.

Attach a shell to the running container and create a simple “Hello World” page:

```bash
# Attach a shell to the running apache container
sudo docker exec -it dockerlab-apache /bin/sh

# Create a new main HTML file
echo '<html><body><h1>Hello world!</h1></body></html>' > htdocs/index.html
```

Now, open a new ssh towards the VM (without exiting from the previous), and issue the same `wget` command as before — you should see your new content.

> [!IMPORTANT]
> Directly modifying files inside containers is almost always a **bad practice**.
> Changes are not persisted in the base image, and will be lost if a new container is created.
> Even embedding code within an image (via a Dockerfile) would require rebuilding the image each time, which is inefficient for fast development cycles.

## 4.3. Populating the Apache Container with External HTML Pages

A better solution involves mounting external files from the host.

First, stop the container:

```bash
sudo docker container stop dockerlab-apache
```

Then, prepare a local directory and HTML file:

```bash
mkdir --parents docker-lab/apache
echo '<html><body><h1>Hello world!</h1></body></html>' > docker-lab/apache/index.html
```

Now, start the container again, using the `-v` flag to *bind mount* your local folder into the container:

```bash
sudo docker run -d --name dockerlab-apache --rm -p 8080:80 \
  -v ${PWD}/docker-lab/apache:/usr/local/apache2/htdocs:ro httpd:2.4-alpine
```

The `-v` flag is used to mount a directory from the host machine into the container. In this case:

* `${PWD}/docker-lab/apache` is the path to the local folder on the host machine.
* `/usr/local/apache2/htdocs` is the target directory inside the container where the files will be accessible.
* `:ro` specifies that the mount is **read-only**, meaning the container can read the files but cannot modify them.

This approach allows you to serve content from your local machine without embedding it directly into the container, enabling faster updates and better separation of concerns.

> [!NOTE]
> According to the [official documentation](https://docs.docker.com/storage/volumes/),
> *“Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.”*
>
> Here, the volume is mounted as **read-only (`ro`)**, since files do not need to be modified inside the container.

Now, check again using the `wget` command if the webpage has been correctly mounted. By using volume mount, you can now update the served content simply by editing the files in your local folder.

Finally, stop the container:

```bash
sudo docker container stop dockerlab-apache
```

## 4.4. Creating a User-Defined Bridge

Before connecting the web server and database, create a **user-defined bridge** network.
While the default bridge works, user-defined bridges allow **automatic DNS resolution** between containers.

```bash
sudo docker network create dockerlab-network
```

## 4.5. Running the Database Server

Now, let’s run the `mariadb` container.

Now run the following initialization script to create the appropriate tables for the DB on your local system:

```bash
mkdir --parents docker-lab/mariadb/database
mkdir --parents docker-lab/mariadb/scripts

# Create a first file '01-create-tables.sql' that contains the SQL
# required to create a database table
cat <<'EOF' > docker-lab/mariadb/scripts/01-create-tables.sql
CREATE TABLE DOCKER_IMAGES (
    NAME    VARCHAR(100) NOT NULL,
    VERSION VARCHAR(100) NOT NULL,
    PRIMARY KEY (NAME)
);
EOF

# Create a second file '02-insert.sql' that contains the SQL 
# required to add some data in the previous table
cat <<'EOF' > docker-lab/mariadb/scripts/02-insert.sql
INSERT INTO DOCKER_IMAGES(NAME, VERSION) VALUES ("httpd", "2.4-alpine");
INSERT INTO DOCKER_IMAGES(NAME, VERSION) VALUES ("mariadb", "10");
EOF
```

Then, run the container:

```bash
sudo docker run -d --name dockerlab-mariadb --rm --network dockerlab-network \
  -e MYSQL_DATABASE=database -e MYSQL_ROOT_PASSWORD=rootpass \
  -e MYSQL_USER=testuser -e MYSQL_PASSWORD=testpass \
  -v ${PWD}/docker-lab/mariadb/database:/var/lib/mysql \
  -v ${PWD}/docker-lab/mariadb/scripts:/docker-entrypoint-initdb.d:ro \
  mariadb:10.7
```

**Explanation:**

* `--network`: connects the container to the `dockerlab-network` bridge.
* `-e`: passes environment variables used to configure the database.
* `-v <source>:<dest>`: mounts folders from the host into the container.

  * Database data → `/var/lib/mysql`
  * Initialization scripts → `/docker-entrypoint-initdb.d`

> [!WARNING]
> Using environment variables to store passwords is insecure in production. Use secret management tools instead.

> [!NOTE]
> Initialization scripts and environment variables are applied **only** the first time the database is created.
> If you recreate the container while keeping the same local database folder, initialization will be skipped.

Check the setup by running a MySQL shell inside the container:

```bash
sudo docker exec -it dockerlab-mariadb \
  mysql --user=testuser --password=testpass --database=database
```

If this fails, the server may still be initializing. Check logs with:

```bash
sudo docker logs --follow dockerlab-mariadb
```

Once the prompt appears (`MariaDB [database]>`), try:

```sql
SELECT * FROM DOCKER_IMAGES;
quit
```

You should see the contents of the created table.

## 4.6. Creating a Custom Image with Dockerfiles

Now that the `mariadb` server is running, let’s build a custom `apache-php` image that reads data from the database.
Although ready-to-use images exist (see [Docker Hub PHP](https://hub.docker.com/_/php#phpversion-apache)), we will create one from scratch.

A **Dockerfile** is a text document containing all the commands to build an image automatically.

Execute the following script to create all the required directoried and initialize the `Dockerfile`:

```bash
# Create the required folders
mkdir --parents docker-lab/apache-php/docker
mkdir --parents docker-lab/apache-php/html

# Now, let's create the Dockerfile to build our custom container
cat <<'EOF' > docker-lab/apache-php/docker/Dockerfile
FROM alpine:3.10

# Run the command to install the required packages
RUN apk add --update --no-cache apache2 php7-apache2 php7-mysqli

# Allow graceful termination of apache
# https://httpd.apache.org/docs/2.4/stopping.html#gracefulstop
STOPSIGNAL WINCH

# Expose the http port
EXPOSE 80

# Execute apache in foreground as default
CMD ["/usr/sbin/httpd", "-DFOREGROUND"]
EOF
 
```

In the `Dockerfile` we can find the following constructs:

* **FROM:** Specifies the base image.
* **RUN:** Executes commands to build image layers (e.g., install packages).
  In this case, it installs Apache, PHP, and the MySQLi extension.
* **STOPSIGNAL:** Defines the signal used to stop the container gracefully.
* **EXPOSE:** Declares which ports the container listens on.
* **CMD:** Defines the default command when the container runs (e.g., start Apache).

Build the image:

```bash
sudo docker build --tag dockerlab-apache-php docker-lab/apache-php/docker
```

Inspect build layers:

```bash
sudo docker history --no-trunc dockerlab-apache-php
```

Now, create a PHP page that connects to the mariadb database previously created.

```bash
cat <<'EOF' > docker-lab/apache-php/html/index.php
<?php
$server = "dockerlab-mariadb";
$username = "testuser";
$password = "testpass";
$database = "database";

$connection = new mysqli($server, $username, $password, $database);
if ($connection->connect_error) {
   die("Connection failed: " . $connection->connect_error);
}

$query = "SELECT * FROM DOCKER_IMAGES";
$result = $connection->query($query);

echo "<center><table border='1' cellpadding='10'>";
echo "<tr><th>Name</th><th>Version</th></tr>";
while ($row = $result->fetch_assoc()) {
    echo "<tr><td>" . $row["NAME"] . "</td>";
    echo "<td>" . $row["VERSION"] ."</td></tr>";
}
echo "</table></center>";
?>
EOF
```

The PHP script connects to the `mariadb` database using the `mysqli` extension. It retrieves the contents of the `DOCKER_IMAGES` table and dynamically generates an HTML table to display the data. Here's a breakdown of the script:

1. **Database Connection:**  
  The script establishes a connection to the `mariadb` container using the hostname `dockerlab-mariadb`, along with the username, password, and database name defined earlier.

2. **Error Handling:**  
  If the connection fails, the script terminates and displays an error message.

3. **Query Execution:**  
  The script executes a SQL query (`SELECT * FROM DOCKER_IMAGES`) to fetch all rows from the `DOCKER_IMAGES` table.

4. **HTML Table Generation:**  
  The script iterates over the query results and constructs an HTML table with two columns: `Name` and `Version`. Each row in the database corresponds to a row in the HTML table.

5. **Output:**  
  The generated HTML table is displayed in the browser when the `index.php` page is accessed.

This script demonstrates how to integrate PHP with a MySQL database to create dynamic web content.

> [!NOTE]
> The PHP script refers to the database server by **container name** (`dockerlab-mariadb`) instead of IP address.
> This works because both containers are attached to the same user-defined network (`dockerlab-network`).

Run the custom web server container:

```bash
sudo docker run -d --name dockerlab-apache-php --rm -p 8080:80 \
  -v ${PWD}/docker-lab/apache-php/html:/var/www/localhost/htdocs:ro \
  --network dockerlab-network dockerlab-apache-php
```

Visit [http://localhost:8080](http://localhost:8080) — you should see the table contents from the `mariadb` database.

## 4.7. (Optional) Publishing Your Image to Docker Hub

To share your image publicly, log in to Docker Hub:

```bash
sudo docker login
```

Tag and push your image:

```bash
sudo docker tag dockerlab-apache-php <your-username>/dockerlab-apache-php:1.0-alpine
sudo docker push <your-username>/dockerlab-apache-php:1.0-alpine
```

> Image names follow the format:
> `repository/image:tag`
> e.g., `stefanog/dockerlab-apache-php:1.0-alpine`

> [!WARNING]
> Remember to log out after use if on a shared computer:
>
> ```bash
> sudo docker logout
> ```

## 4.8. Cleaning Up the Environment

Before moving on, stop all containers and remove the network:

```bash
sudo docker container stop dockerlab-apache-php
sudo docker container stop dockerlab-mariadb
sudo docker network rm dockerlab-network
```
