<table style="width:100%">
  <tr>
    <td align="left"><a href="../1.3/README.md">⬅️ Previous</a></td>
    <td align="right"><a href="../1.5/README.md">Next ➡️</a></td>
  </tr>
</table>

# 4. Running a Real Service (LAMP Stack)

This section creates a basic **LAMP stack** (Linux, Apache, MariaDB, PHP) based on Dockerized components.
Following the *“one service per container”* philosophy, two separate containers will be run:
one executing the web server (`apache` with the `php` interpreter) and one handling the database server (`mariadb`).

Modularity is a very important concept in Docker, as it keeps applications separated, improves maintainability, and enables the reuse of containers across different setups.

## 4.1. Running the Web Server

Create a new `apache` container:

```bash
docker run -d --name dockerlab-apache --rm -p 8080:80 httpd:2.4-alpine
```

**Explanation:**

* `-d`: runs the container in the background.

  > **Note:** Without this flag, Apache starts using the console as its standard input/output, preventing the execution of other commands in the same shell.

* `-p`: exposes the container’s internal port `80` (HTTP) on port `8080` of the host.
  This makes the application appear as if it were running directly on the host.

To verify that the web server is working, open [http://localhost:8080](http://localhost:8080) in your browser,
or run:

```bash
curl http://localhost:8080
```

You should see the message **“It works!”**.

## 4.2. Populating the Apache Container with Embedded HTML Pages

You now have a running web server container.
However, it is useless unless you can specify the content to be served.

Attach a shell to the running container and create a simple “Hello World” page:

```bash
# Attach a shell to the running apache container
docker exec -it dockerlab-apache /bin/sh

# Create a new main HTML file
echo '<html><body><h1>Hello world!</h1></body></html>' > htdocs/index.html
```

Now, refresh the web page — you should see your new content.

> [|IMPORTANT]
> Directly modifying files inside containers is almost always a **bad practice**.
> Changes are not persisted in the base image, and will be lost if a new container is created.
> Even embedding code within an image (via a Dockerfile) would require rebuilding the image each time, which is inefficient for fast development cycles.

## 4.3. Populating the Apache Container with External HTML Pages

A better solution involves mounting external files from the host.

First, stop the container:

```bash
docker container stop dockerlab-apache
```

Then, prepare a local directory and HTML file:

```bash
mkdir --parents docker-lab/apache
echo '<html><body><h1>Hello world!</h1></body></html>' > docker-lab/apache/index.html
```

Now, start the container again, using the `-v` flag to *bind mount* your local folder into the container:

```bash
docker run -d --name dockerlab-apache --rm -p 8080:80 \
  -v ${PWD}/docker-lab/apache:/usr/local/apache2/htdocs:ro httpd:2.4-alpine
```

> [!NOTE]
> According to the [official documentation](https://docs.docker.com/storage/volumes/),
> *“Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.”*
>
> Here, the volume is mounted as **read-only (`ro`)**, since files do not need to be modified inside the container.

After refreshing the page, you can now update the served content simply by editing the files in your local folder.

Finally, stop the container:

```bash
docker container stop dockerlab-apache
```

## 4.4. Creating a User-Defined Bridge

Before connecting the web server and database, create a **user-defined bridge** network.
While the default bridge works, user-defined bridges allow **automatic DNS resolution** between containers.

```bash
docker network create dockerlab-network
```

## 4.5. Running the Database Server

Now, let’s run the `mariadb` container.

First, create a directory for persistent storage and SQL initialization scripts:

```bash
# Example (refer to your snippet file 3A-DatabaseInit.sh)
mkdir -p docker-lab/mariadb/{database,scripts}
# add SQL initialization scripts in docker-lab/mariadb/scripts/
```

Then, run the container:

```bash
docker run -d --name dockerlab-mariadb --rm --network dockerlab-network \
  -e MYSQL_DATABASE=database -e MYSQL_ROOT_PASSWORD=rootpass \
  -e MYSQL_USER=testuser -e MYSQL_PASSWORD=testpass \
  -v ${PWD}/docker-lab/mariadb/database:/var/lib/mysql \
  -v ${PWD}/docker-lab/mariadb/scripts:/docker-entrypoint-initdb.d:ro \
  mariadb:10.7
```

**Explanation:**

* `--network`: connects the container to the `dockerlab-network` bridge.
* `-e`: passes environment variables used to configure the database.
* `-v <source>:<dest>`: mounts folders from the host into the container.

  * Database data → `/var/lib/mysql`
  * Initialization scripts → `/docker-entrypoint-initdb.d`

> [!WARNING]
> Using environment variables to store passwords is insecure in production. Use secret management tools instead.

> [!NOTE]
> Initialization scripts and environment variables are applied **only** the first time the database is created.
> If you recreate the container while keeping the same local database folder, initialization will be skipped.

Check the setup by running a MySQL shell inside the container:

```bash
docker exec -it dockerlab-mariadb \
  mysql --user=testuser --password=testpass --database=database
```

If this fails, the server may still be initializing. Check logs with:

```bash
docker logs --follow dockerlab-mariadb
```

Once the prompt appears (`MariaDB [database]>`), try:

```sql
SELECT * FROM DOCKER_IMAGES;
quit
```

You should see the contents of the created table.

## 4.6. Creating a Custom Image with Dockerfiles

Now that the `mariadb` server is running, let’s build a custom `apache-php` image that reads data from the database.
Although ready-to-use images exist (see [Docker Hub PHP](https://hub.docker.com/_/php#phpversion-apache)), we will create one from scratch.

A **Dockerfile** is a text document containing all the commands to build an image automatically.

Example setup (based on your `3B-Dockerfile.sh` snippet):

```bash
# Directory structure
mkdir -p docker-lab/apache-php/docker
# Create your Dockerfile inside that directory
```

### 4.6.1. Common Dockerfile Instructions

* **FROM:** Specifies the base image.
* **RUN:** Executes commands to build image layers (e.g., install packages).
  In this case, it installs Apache, PHP, and the MySQLi extension.
* **STOPSIGNAL:** Defines the signal used to stop the container gracefully.
* **EXPOSE:** Declares which ports the container listens on.
* **CMD:** Defines the default command when the container runs (e.g., start Apache).

Build the image:

```bash
docker build --tag dockerlab-apache-php docker-lab/apache-php/docker
```

Inspect build layers:

```bash
docker history --no-trunc dockerlab-apache-php
```

Now, create a PHP page that connects to the database (see `3C-PhpScript.sh`).

> [!NOTE]
> The PHP script refers to the database server by **container name** (`dockerlab-mariadb`) instead of IP address.
> This works because both containers are attached to the same user-defined network (`dockerlab-network`).

Run the custom web server container:

```bash
docker run -d --name dockerlab-apache-php --rm -p 8080:80 \
  -v ${PWD}/docker-lab/apache-php/html:/var/www/localhost/htdocs:ro \
  --network dockerlab-network dockerlab-apache-php
```

Visit [http://localhost:8080](http://localhost:8080) — you should see the table contents from the `mariadb` database.

## 4.7. (Optional) Publishing Your Image to Docker Hub

To share your image publicly, log in to Docker Hub:

```bash
docker login
```

Tag and push your image:

```bash
docker tag dockerlab-apache-php <your-username>/dockerlab-apache-php:1.0-alpine
docker push <your-username>/dockerlab-apache-php:1.0-alpine
```

> Image names follow the format:
> `repository/image:tag`
> e.g., `stefanog/dockerlab-apache-php:1.0-alpine`

> [!WARNING]
> Remember to log out after use if on a shared computer:
>
> ```bash
> docker logout
> ```

## 4.8. Cleaning Up the Environment

Before moving on, stop all containers and remove the network:

```bash
docker container stop dockerlab-apache-php
docker container stop dockerlab-mariadb
docker network rm dockerlab-network
```
